const JSZip = require("jszip");
const Project = require("../models/Project");
const Database = require("../models/Database");
const Table = require("../models/Table");
const Endpoint = require("../models/Endpoint");
const DB_Config = require("../models/DB_Config");
const crypto = require("../utils/crypto");

const LIB_VERSIONS = {
    express: "^4.19.2",
    cors: "^2.8.5",
    dotenv: "^16.4.5",
    nodemon: "^3.1.0",
    mongoose: "^8.2.0",
    pg: "^8.11.3",
    sequelize: "^6.37.1",
    mysql2: "^3.9.2"
};

const generatePackageJson = (projectName, dbType) => {
    const dependencies = {
        "express": LIB_VERSIONS.express,
        "cors": LIB_VERSIONS.cors,
        "dotenv": LIB_VERSIONS.dotenv,
    };
    const devDependencies = { "nodemon": LIB_VERSIONS.nodemon };

    if (dbType === 'postgresql') {
        dependencies["pg"] = LIB_VERSIONS.pg;
        dependencies["sequelize"] = LIB_VERSIONS.sequelize;
    } else if (dbType === 'mysql') {
        dependencies["mysql2"] = LIB_VERSIONS.mysql2;
        dependencies["sequelize"] = LIB_VERSIONS.sequelize;
    } else if (dbType === 'mongodb') {
        dependencies["mongoose"] = LIB_VERSIONS.mongoose;
    }

    return JSON.stringify({
        name: projectName.toLowerCase().replace(/[^a-z0-9-]/g, '-'),
        version: "1.0.0",
        description: "Generated by DragEnd",
        main: "server.js",
        scripts: { "start": "node server.js", "dev": "nodemon server.js" },
        dependencies,
        devDependencies
    }, null, 2);
};

const generateDotEnv = (port, dbType, dbConfig, dbName) => {
    let envContent = `PORT=${port}\n`;
    if (!dbConfig) return envContent + `# DB Config Missing`;

    const creds = dbConfig.credentials || {};
    let password = creds.password;
    try { password = crypto.decrypt(creds.password); } catch (e) { }
    const databaseName = dbName || 'myapp';

    if (dbType === 'mongodb') {
        const uri = dbConfig.uri || `mongodb://${creds.host || 'localhost'}:${creds.port || 27017}/${databaseName}`;
        envContent += `MONGO_URI=${uri}\n`;
    } else {
        envContent += `DB_HOST=${creds.host || 'localhost'}\n`;
        envContent += `DB_PORT=${creds.port || 3306}\n`;
        envContent += `DB_USER=${creds.username || 'root'}\n`;
        envContent += `DB_PASS=${password || ''}\n`;
        envContent += `DB_NAME=${databaseName}\n`;
        envContent += `DB_DIALECT=${dbType === 'postgresql' ? 'postgres' : 'mysql'}\n`;
    }
    return envContent;
};

const generateServerJs = (port, dbType) => {
    const dbImport = dbType === 'mongodb'
        ? `const connectDB = require('./models/index');`
        : `const { connectDB } = require('./models/index');`;

    return `const express = require('express');
const app = express();
const cors = require('cors');
require('dotenv').config();
const routes = require('./routes'); 
${dbImport}

const PORT = process.env.PORT || ${port};

// Middleware
app.use(cors());
app.use(express.json());

// Database Connection
connectDB();

// Routes
app.use('/api', routes); // Mounts all routes under /api

// Start Server
app.listen(PORT, () => {
  console.log(\`Server running on: http://localhost:\${PORT}\`);
});
`;
};

const generateDbConnection = (dbType, tableNames) => {
    if (dbType === 'mongodb') {
        return `const mongoose = require('mongoose');

const connectDB = async () => {
  try {
    await mongoose.connect(process.env.MONGO_URI);
    console.log("MongoDB Connected Successfully");
  } catch (err) {
    console.error("MongoDB Connection Error:", err.message);
    process.exit(1);
  }
};

module.exports = connectDB;`;
    } else {
        const modelImports = tableNames.map(name =>
            `db.${name} = require('./${name}')(sequelize, DataTypes);`
        ).join('\n');

        return `const { Sequelize, DataTypes } = require('sequelize');

const sequelize = new Sequelize(
  process.env.DB_NAME,
  process.env.DB_USER,
  process.env.DB_PASS,
  {
    host: process.env.DB_HOST,
    dialect: process.env.DB_DIALECT,
    port: process.env.DB_PORT,
    logging: false
  }
);

const db = {};
db.Sequelize = Sequelize;
db.sequelize = sequelize;

// Import Models
${modelImports}

// Connection Function
db.connectDB = async () => {
  try {
    await sequelize.authenticate();
    console.log('Database Connected...');
    await sequelize.sync({ alter: true }); 
    console.log('Tables Synced...');
  } catch (err) {
    console.error('Error: ' + err);
  }
};

module.exports = db;`;
    }
};

const generateModelFile = (table, dbType) => {
    const getSqlType = (t) => {
        if (t === 'string') return 'DataTypes.STRING';
        if (t === 'number') return 'DataTypes.INTEGER';
        if (t === 'boolean') return 'DataTypes.BOOLEAN';
        if (t === 'date') return 'DataTypes.DATE';
        return 'DataTypes.STRING';
    };

    const getMongoType = (t) => {
        if (t === 'string') return 'String';
        if (t === 'number') return 'Number';
        if (t === 'boolean') return 'Boolean';
        if (t === 'date') return 'Date';
        return 'String';
    };

    if (dbType === 'mongodb') {
        const fields = table.fields.map(f => {
            return `  ${f.name}: { type: ${getMongoType(f.type)}, required: ${f.required || false}, unique: ${f.constraint === 'unique'} }`;
        }).join(',\n');

        return `const mongoose = require('mongoose');

const ${table.name}Schema = new mongoose.Schema({
${fields}
}, { timestamps: true });

module.exports = mongoose.model('${table.name}', ${table.name}Schema);`;

    } else {
        const fields = table.fields.map(f => {
            return `    ${f.name}: {
      type: ${getSqlType(f.type)},
      allowNull: ${!f.required},
      unique: ${f.constraint === 'unique'},
      primaryKey: ${f.constraint === 'primary'}
    }`;
        }).join(',\n');

        return `module.exports = (sequelize, DataTypes) => {
  const ${table.name} = sequelize.define('${table.name}', {
${fields}
  });
  return ${table.name};
};`;
    }
};

const generateController = (tableName, endpoints, dbType) => {
    const modelName = tableName; // e.g., 'User'

    let code = dbType === 'mongodb'
        ? `const ${modelName} = require('../models/${modelName}');\n\n`
        : `const db = require('../models');\nconst ${modelName} = db.${modelName};\n\n`;

    endpoints.forEach(ep => {
        const funcName = ep.route.replace(/^\//, '').replace(/[^a-zA-Z0-9]/g, '');

        code += `exports.${funcName} = async (req, res) => {\n`;
        code += `  try {\n`;

        if (ep.method === 'GET') {
            const select = ep.selectedFields && ep.selectedFields.length > 0
                ? (dbType === 'mongodb' ? `.select('${ep.selectedFields.join(' ')}')` : `, { attributes: [${ep.selectedFields.map(f => `'${f}'`).join(',')}] }`)
                : '';

            if (dbType === 'mongodb') {
                code += `    const data = await ${modelName}.find({})${select};\n`;
            } else {
                code += `    const data = await ${modelName}.findAll(${select ? select.substring(2) : ''});\n`;
            }
            code += `    res.status(200).json(data);\n`;

        } else if (ep.method === 'POST') {
            code += `    const newData = await ${modelName}.create(req.body);\n`;
            code += `    res.status(201).json(newData);\n`;

        } else if (ep.method === 'PUT') {
            code += `    // Update logic here\n`;
            code += `    res.status(200).json({ msg: "Update endpoint hit" });\n`;
        } else if (ep.method === 'DELETE') {
            code += `    // Delete logic here\n`;
            code += `    res.status(200).json({ msg: "Delete endpoint hit" });\n`;
        }

        code += `  } catch (err) {\n`;
        code += `    res.status(500).json({ error: err.message });\n`;
        code += `  }\n`;
        code += `};\n\n`;
    });

    return code;
};

const generateRouteFile = (controllerName, endpoints) => {
    let code = `const express = require('express');\n`;
    code += `const router = express.Router();\n`;
    code += `const controller = require('../controllers/${controllerName}');\n\n`;

    endpoints.forEach(ep => {
        const funcName = ep.route.replace(/^\//, '').replace(/[^a-zA-Z0-9]/g, '');
        const routePath = ep.route.startsWith('/') ? ep.route : `/${ep.route}`;
        code += `router.${ep.method.toLowerCase()}('${routePath}', controller.${funcName});\n`;
    });

    code += `\nmodule.exports = router;`;
    return code;
};


exports.downloadProject = async (req, res) => {
    try {
        const { projectId } = req.params;

        const project = await Project.findById(projectId);
        if (!project) return res.status(404).json({ msg: "Project not found" });

        const database = await Database.findOne({ projectId: project._id }).populate('config');
        const dbType = database ? database.type : 'mongodb';
        const dbConfig = database ? database.config : null;
        const dbName = database ? database.name : 'myapp';

        const tables = await Table.find({ projectId });
        const endpoints = await Endpoint.find({ projectId });

        const groupedEndpoints = {};
        const tableIdToName = {};

        tables.forEach(t => tableIdToName[t._id.toString()] = t.name);

        endpoints.forEach(ep => {
            let tableName = 'General';
            if (ep.connectedTableId && tableIdToName[ep.connectedTableId.toString()]) {
                tableName = tableIdToName[ep.connectedTableId.toString()];
            }
            if (!groupedEndpoints[tableName]) groupedEndpoints[tableName] = [];
            groupedEndpoints[tableName].push(ep);
        });

        const zip = new JSZip();

        zip.file("package.json", generatePackageJson(project.name, dbType));
        zip.file(".env", generateDotEnv(8080, dbType, dbConfig, dbName));
        zip.file("server.js", generateServerJs(8080, dbType));
        zip.file("README.md", `# ${project.name}\nGenerated Backend Project`);

        const modelsFolder = zip.folder("models");
        const tableNames = tables.map(t => t.name);
        modelsFolder.file("index.js", generateDbConnection(dbType, tableNames));
        tables.forEach(table => {
            modelsFolder.file(`${table.name}.js`, generateModelFile(table, dbType));
        });

        const controllersFolder = zip.folder("controllers");
        const routesFolder = zip.folder("routes");
        let routesIndexContent = `const router = require('express').Router();\n\n`;

        Object.keys(groupedEndpoints).forEach(tableName => {
            const groupEndpoints = groupedEndpoints[tableName];
            const controllerName = `${tableName}Controller`;

            controllersFolder.file(`${controllerName}.js`, generateController(tableName, groupEndpoints, dbType));

            routesFolder.file(`${tableName}.js`, generateRouteFile(controllerName, groupEndpoints));

            routesIndexContent += `const ${tableName}Routes = require('./${tableName}');\n`;
            routesIndexContent += `router.use('/${tableName.toLowerCase()}', ${tableName}Routes);\n`;
        });

        routesIndexContent += `\nmodule.exports = router;`;
        routesFolder.file("index.js", routesIndexContent);

        const content = await zip.generateAsync({ type: "nodebuffer" });
        res.set({
            'Content-Type': 'application/zip',
            'Content-Disposition': `attachment; filename=${project.name.replace(/\s+/g, '_')}.zip`,
            'Content-Length': content.length
        });
        return res.send(content);

    } catch (err) {
        console.error("Generator Error:", err);
        return res.status(500).json({ msg: "Failed to generate project" });
    }
};